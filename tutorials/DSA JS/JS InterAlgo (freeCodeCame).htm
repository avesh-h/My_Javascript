<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1 id="heading">Hello Avesh</h1>
    <div>
      DIV
      <form>
        FORM
        <button>Button</button>
      </form>
    </div>
    <ul class="products">
      <li class="mobile">Mobile</li>
      <li class="cars">cars</li>
      <li class="sports">sports</li>
    </ul>
    <script>
      //1)We'll pass you an array of two numbers. Return the sum of those two numbers plus the sum of all the numbers between them. The lowest number will not always come first.

      //   For example, sumAll([4,1]) should return 10 because sum of all the numbers between 1 and 4 (both inclusive) is 10.

      //   function sumAll(arr) {
      //     let sum = 0;
      //     arr.sort((a, b) => (a > b ? 1 : -1));
      //     for (let i = arr[0]; i <= arr[1]; i++) {
      //       sum = sum + i;
      //     }
      //     return sum;
      //   }

      //OR

      //   function sumAll(arr) {
      //     let max = Math.max(arr[0], arr[1]);
      //     let min = Math.min(arr[0], arr[1]);
      //     let sum = 0;
      //     for (let i = min; i <= max; i++) {
      //       sum = sum + i;
      //     }
      //     return sum;
      //   }

      //   sumAll([4, 1]);

      //MOST IMPORTANT EXAMPLE THAT HELP YOU TO UNDERSTAND HOW TO COMPARE ELEMENTS OF TWO ARRAYS

      //2)Compare two arrays and return a new array with any items only found in one of the two given arrays, but not both. In other words, return the symmetric difference of the two arrays.

      // Note: You can return the array with its elements in any order.

      // function diffArray(arr1, arr2) {
      //   const newArr = [];
      //   const mergedArr = arr1.concat(arr2);
      //   for (let i = 0; i < mergedArr.length; i++) {
      //     if (!arr1.includes(mergedArr[i]) || !arr2.includes(mergedArr[i])) {
      //       newArr.push(mergedArr[i]);
      //     }
      //   }
      //   return newArr;
      // }

      //or

      //In this example we create function that compares both array and in function calling we interchange position of array for executing functionality in first case we check first array values inside second array and then in second calling we check second elements in first array

      // function diffArray(arr1, arr2) {
      //   const newArr = [];
      //   function checkArr(first, second) {
      //     for (let i = 0; i < first.length; i++) {
      //       if (second.indexOf(first[i])===-1) {
      //         newArr.push(first[i]);
      //       }
      //     }
      //   }
      //   checkArr(arr1, arr2);
      //   checkArr(arr2, arr1);
      //   return newArr;
      // }

      //OR

      //In this mehod simply we merge to array and then apply filte and check the merged array's each elment is exist inside the arr1 or arr2

      // function diffArray(arr1, arr2) {
      //   return arr1
      //     .concat(arr2)
      //     .filter((e) => !arr1.includes(e) || !arr2.includes(e));
      // }

      // diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5]);
      // diffArray(["andesite", "grass", "dirt", "pink wool", "dead shrub"], ["diorite", "andesite", "grass", "dirt", "dead shrub"])

      //3)You will be provided with an initial array (the first argument in the destroyer function), followed by one or more arguments. Remove all elements from the initial array that are of the same value as these arguments.

      // Note: You have to use the arguments object.

      // function destroyer(arr, ...arg) {
      //   const newArr = [];
      //   for (let i = 0; i < arr.length; i++) {
      //     if (arg.indexOf(arr[i]) === -1) {
      //       newArr.push(arr[i]);
      //     }
      //   }
      //   return newArr;
      // }

      //OR

      // function destroyer(arr, ...arg) {
      //   return arr.filter((e) => !arg.includes(e));
      // }

      // destroyer([1, 2, 3, 5, 1, 2, 3], 2, 3);

      //4)For example, if the first argument is [{ first: "Romeo", last: "Montague" }, { first: "Mercutio", last: null }, { first: "Tybalt", last: "Capulet" }], and the second argument is { last: "Capulet" }, then you must return the third object from the array (the first argument), because it contains the name and its value, that was passed on as the second argument.

      // function whatIsInAName(collection, source) {
      //   const newSource = Object.keys(source);
      //   let newArr = collection.filter((obj) => {
      //     for (let i = 0; i < newSource.length; i++) {
      //       if (
      //         !obj.hasOwnProperty(newSource[i]) ||
      //         obj[newSource[i]] !== source[newSource[i]]
      //       ) {
      //         return false;
      //       }
      //     }
      //     return true;
      //   });
      //   return newArr;
      // }

      //OR

      // function whatIsInAName(collection, source) {
      //   const newSource = Object.keys(source);
      //   let newArr = collection.filter((obj) =>
      //     newSource.every((e) => obj.hasOwnProperty(e) && obj[e] === source[e])
      //   );
      //   return newArr;
      // }

      // whatIsInAName([{ first: "Romeo", last: "Montague" }, { first: "Mercutio", last: null }, { first: "Tybalt", last: "Capulet" }], { last: "Capulet" });

      // whatIsInAName([{ "apple": 1 }, { "apple": 1 }, { "apple": 1, "bat": 2 }], { "apple": 1 })

      // whatIsInAName([{ "apple": 1, "bat": 2 }, { "bat": 2 }, { "apple": 1, "bat": 2, "cookie": 2 }], { "apple": 1, "bat": 2 ,"cookie": 2 })

      // whatIsInAName([{ "apple": 1, "bat": 2 }, { "apple": 1 }, { "apple": 1, "bat": 2, "cookie": 2 }], { "apple": 1, "cookie": 2 })

      //Practice example of above example

      // const arr1 = ["pop", "red", "lor", 3, 5, true, "sting", "orange", 55];

      // const arr2 = ["red", true];

      // const checkArr = (arr1, arr2) => {
      //   const newArr = [];
      //   for (let ele of arr2) {
      //     if (!arr1.includes(ele)) {
      //       return [];
      //     } else {
      //       newArr.push(ele);
      //     }
      //   }
      //   return newArr;
      // };

      //OR

      // const checkArr = (arr1, arr2) => {
      //   let newArr = arr1.filter((e) => arr2.includes(e));
      //   return newArr;
      // };

      // const myArr = checkArr(arr1, arr2);
      // console.log(myArr);

      //5)Convert a string to spinal case. Spinal case is all-lowercase-words-joined-by-dashes.

      // function spinalCase(str) {
      //   //For Remove (_)
      //   // var regex = /\s+|_+/g;

      //   return str
      //     .replace(/([A-Z])|\s+|_+|-+/g, " $1")
      //     .toLowerCase()
      //     .split(" ")
      //     .filter((e) => e)
      //     .join("-");
      // }

      //6)Translate the provided string to Pig Latin. Input strings are guaranteed to be English words in all lowercase.

      // function translatePigLatin(str) {
      //   const vowels = ["a", "e", "i", "o", "u"];
      //   let mainStr;
      //   for (let i = 0; i < str.length; i++) {
      //     if (vowels.includes(str[i])) {
      //       if (i === 0) {
      //         mainStr = str + "way";
      //         break;
      //       } else {
      //         let getChars = str.substring(0, i);
      //         mainStr = str.substring(i) + getChars + "ay";
      //         break;
      //       }
      //     }
      //     mainStr = str + "ay";
      //   }
      //   return mainStr;
      // }

      //OR
      // function translatePigLatin(str) {
      //   if (str.match(/^[aeiou]/)) return str + "way";

      //   const consonantCluster = str.match(/^[^aeiou]+/)[0];
      //   return str.substring(consonantCluster.length) + consonantCluster + "ay";
      // }

      // translatePigLatin("consonant");
      // translatePigLatin("algorithm");
      // translatePigLatin("schwartz");
      // translatePigLatin("rhythm")
      // translatePigLatin("paragraphs")+-
      // translatePigLatin("glove")

      // let text = "The rain in SPAIN stays mainly in the plain";
      // let result = text.match("ain");
      // console.log(result.index);
      // console.log(text.substring(0, result));

      //7)Perform a search and replace on the sentence using the arguments provided and return the new sentence.

      // First argument is the sentence to perform the search and replace on.

      // Second argument is the word that you will be replacing (before).

      // Third argument is what you will be replacing the second argument with (after).

      // Note: Preserve the case of the first character in the original word when you are replacing it. For example if you mean to replace the word Book with the word dog, it should be replaced as Dog

      // function myReplace(str, before, after) {
      //   if (before.match(/[A-Z]/)) {
      //     const converter = after.charAt(0).toUpperCase() + after.slice(1);
      //     str = str.replace(before, converter);
      //   } else {
      //     const converter = after.charAt(0).toLowerCase() + after.slice(1);
      //     str = str.replace(before, converter);
      //   }
      //   return str;
      // }

      //OR

      // function myReplace(str, before, after) {
      //   const index = str.indexOf(before);
      //   if (str[index] === str[index].toUpperCase()) {
      //     after = after.charAt(0).toUpperCase() + after.slice(1);
      //     str = str.replace(before, after);
      //   } else {
      //     after = after.charAt(0).toLowerCase() + after.slice(1);
      //     str = str.replace(before, after);
      //   }
      //   return str;
      // }

      // myReplace("A quick brown fox jumped over the lazy dog", "jumped", "leaped");

      // myReplace("He is Sleeping on the couch", "Sleeping", "sitting")

      // myReplace("I think we should look up there", "up", "Down")

      //8)Pairs of DNA strands consist of nucleobase pairs. Base pairs are represented by the characters AT and CG, which form building blocks of the DNA double helix.

      // The DNA strand is missing the pairing element. Write a function to match the missing base pairs for the provided DNA strand. For each character in the provided string, find the base pair character. Return the results as a 2d array.

      // For example, for the input GCG, return [["G", "C"], ["C","G"], ["G", "C"]]

      // The character and its pair are paired up in an array, and all the arrays are grouped into one encapsulating array.

      // function pairElement(str) {
      //   const newArr = [];
      //   const arr1 = ["G", "C"];
      //   const arr2 = ["T", "A"];
      //   for (let i = 0; i < str.length; i++) {
      //     if (arr1.includes(str[i])) {
      //       if (arr1.indexOf(str[i]) < 1) {
      //         newArr.push(arr1);
      //       } else {
      //         let reversedArr = [...arr1].reverse();
      //         newArr.push(reversedArr);
      //       }
      //     } else {
      //       if (arr2.indexOf(str[i]) < 1) {
      //         newArr.push(arr2);
      //       } else {
      //         let reversedArr = [...arr2].reverse();
      //         newArr.push(reversedArr);
      //       }
      //     }
      //   }
      //   return newArr;
      // }

      //OR

      // function pairElement(str) {
      //   function singleChar(char) {
      //     switch (char) {
      //       case "A":
      //         return ["A", "T"];
      //       case "T":
      //         return ["T", "A"];
      //       case "G":
      //         return ["G", "C"];
      //       case "C":
      //         return ["C", "G"];
      //     }
      //   }
      //   let newPair = [];
      //   for (let i = 0; i < str.length; i++) {
      //     newPair.push(singleChar(str[i]));
      //   }
      //   return newPair;
      // }

      // pairElement("GCG");
      // pairElement("ATCGA");

      //9)Find the missing letter in the passed letter range and return it.

      // If all letters are present in the range, return undefined.

      // function fearNotLetter(str) {
      //   for (let i = 0; i < str.length; i++) {
      //     if (str.charCodeAt(i + 1) - str.charCodeAt(i) > 1) {
      //       return String.fromCharCode(str.charCodeAt(i) + 1);
      //     }
      //   }
      //   return undefined;
      // }
      // fearNotLetter("abce");
      // // fearNotLetter("abcdefghjklmno")

      //10)Write a function that takes two or more arrays and returns a new array of unique values in the order of the original provided arrays.

      // In other words, all values present from all arrays should be included in their original order, but with no duplicates in the final array.

      // The unique numbers should be sorted by their original order, but the final array should not be sorted in numerical order.

      // Check the assertion tests for examples.

      // function uniteUnique(...arr) {
      //   let newArr = [];
      //   let fullArr = arr.flat();
      //   for (let i = 0; i < fullArr.length; i++) {
      //     if (!newArr.includes(fullArr[i])) {
      //       newArr.push(fullArr[i]);
      //     }
      //   }
      //   return newArr;
      // }

      //OR

      //In this we first convert all argument into single array and then we add filter onto that

      // filter will check that in the whole array there the element index is same as current index if it's not then that means there element is already exist inside the array

      //like example arr[1,2,3,2] if the loop check for last element for (2) that the item (arr.indexOf(item)) it give us 1 beacuse it's already present inside the array so it give us already presented element index which is 1 and compared with current index will be 3 so it's not true so it will remove that element from the array because it's already exist in the array

      // function uniteUnique(...arr) {
      //   let fullArr = arr.flat();
      //   return fullArr.filter((item, ind, arr) => arr.indexOf(item) === ind);
      // }

      //Like which elements are actually repeated in the array

      //OR

      //In this method we use javascript set method is very unique method we can delete add or even check the element is exist inside the array or not

      //Set always store unique values it always remove duplicate elements , we cannot add same value inside Set.

      //if there is case like we don't want to add same elments inside the array again so it maybe very useful method

      // function uniteUnique(...arr) {
      //   let sett = new Set(arr.flat());
      //   return [...sett];
      // }

      // uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1]);
      // uniteUnique([1, 2, 3], [5, 2, 1])
      // uniteUnique([1, 2, 3], [5, 2, 1, 4], [2, 1], [6, 7, 8]);

      //11)Convert the characters &, <, >, " (double quote), and ' (apostrophe), in a string to their corresponding HTML entities.

      // function convertHTML(str) {
      //   let regex = /[&|<|>|"|']/g;
      //   return str.replace(regex, (match) => {
      //     if (match === "&") {
      //       return "&amp;";
      //     } else if (match === "<") {
      //       return "&lt;";
      //     } else if (match === ">") {
      //       return "&gt;";
      //     } else if (match === '"') {
      //       return "&quot;";
      //     } else {
      //       return "&apos;";
      //     }
      //   });
      // }

      // convertHTML("Dolce & Gabbana");

      // 12)Fill in the object constructor with the following methods below:

      // getFirstName()
      // getLastName()
      // getFullName()
      // setFirstName(first)
      // setLastName(last)
      // setFullName(firstAndLast)
      // Run the tests to see the expected output for each method. The methods that take an argument must accept only one argument and it has to be a string. These methods must be the only available means of interacting with the object.

      // const Person = function (firstAndLast) {
      //   let first = firstAndLast.split(" ")[0];
      //   let last = firstAndLast.split(" ")[1];

      //   this.setFirstName = function (firName) {
      //     first = firName;
      //   };

      //   this.setLastName = function (lasName) {
      //     last = lasName;
      //   };

      //   this.setFullName = function (full) {
      //     first = full.split(" ")[0];
      //     last = full.split(" ")[1];
      //   };

      //   this.getFirstName = function () {
      //     return first;
      //   };

      //   this.getLastName = function () {
      //     return last;
      //   };

      //   this.getFullName = function () {
      //     return first + " " + last;
      //   };
      // };

      // const bob = new Person("Bob Ross");
      // bob.getFullName();

      //13)Given the array arr, iterate through and remove each element starting from the first element (the 0 index) until the function func returns true when the iterated element is passed through it.

      // Then return the rest of the array once the condition is satisfied, otherwise, arr should be returned as an empty array.

      // function dropElements(arr, func) {
      //   let newVar = [];
      //   for (let i = 0; i < arr.length; i++) {
      //     if (func(arr[i])) {
      //       newVar = arr.slice(i);
      //       break;
      //     }
      //   }
      //   return newVar;
      // }

      // // dropElements([1, 2, 3], function(n) {return n < 3; });
      // // dropElements([0, 1, 0, 1], function(n) {return n === 1;})
      // dropElements([1, 2, 3, 4], function (n) {
      //   return n > 5;
      // });

      //14)Return an English translated sentence of the passed binary string.

      // The binary string will be space separated.

      // function binaryAgent(str) {
      //   let sp = str.split(" ");
      //   let newArr = sp.map((e) => {
      //     let codeNum = parseInt(e, 2);
      //     return String.fromCharCode(codeNum);
      //   });
      //   return newArr.join("");
      // }

      // binaryAgent(
      //   "01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111"
      // );

      //15)Check if the predicate (second argument) is truthy on all elements of a collection (first argument).

      // In other words, you are given an array collection of objects. The predicate pre will be an object property and you need to return true if its value is truthy. Otherwise, return false.

      // In JavaScript, truthy values are values that translate to true when evaluated in a Boolean context.

      // Remember, you can access object properties through either dot notation or [] notation.

      // function truthCheck(collection, pre) {
      //   let finalVar;
      //   for (let i = 0; i < collection.length; i++) {
      //     finalVar = collection[i][pre];
      //     if (!finalVar) {
      //       return false;
      //     }
      //   }
      //   return !!finalVar;
      // }

      //OR

      // function truthCheck(collection, pre) {
      //   return collection.every((obj) => obj[pre]);
      // }

      // truthCheck([{name: "Quincy", role: "Founder", isBot: false}, {name: "Naomi", role: "", isBot: false}, {name: "Camperbot", role: "Bot", isBot: true}], "isBot");
      // truthCheck(
      //   [
      //     { name: "Quincy", role: "Founder", isBot: false },
      //     { name: "Naomi", role: "", isBot: false },
      //     { name: "Camperbot", role: "Bot", isBot: true },
      //   ],
      //   "name"
      // );

      //FINAL PROJECTS

      //1)Return true if the given string is a palindrome. Otherwise, return false.

      // A palindrome is a word or sentence that's spelled the same way both forward and backward, ignoring punctuation, case, and spacing.

      // Note: You'll need to remove all non-alphanumeric characters (punctuation, spaces and symbols) and turn everything into the same case (lower or upper case) in order to check for palindromes.

      // We'll pass strings with varying formats, such as racecar, RaceCar, and race CAR among others.

      // We'll also pass strings with special symbols, such as 2A3*3a2, 2A3 3a2, and 2_A3*3#A2.

      // function palindrome(str) {
      //   const regex = /[:|(_)-/]/g;
      //   const backStr = str
      //     .toLowerCase()
      //     .split("")
      //     .filter((e) => e !== " ")
      //     .reverse()
      //     .join("")
      //     .replace(regex, "");
      //   const mainStr = str
      //     .toLowerCase()
      //     .split("")
      //     .filter((e) => e !== " ")
      //     .join("")
      //     .replace(regex, "");
      //   if (mainStr !== backStr) {
      //     return false;
      //   }
      //   return true;
      // }

      // palindrome("race car");
      // palindrome("_eye")
      // palindrome("0_0 (: /-\ :) 0-0")
      // palindrome("five|\_/|four")
      // palindrome("not a palindrome")
      // palindrome("My age is 0, 0 si ega ym.");

      //2) One of the simplest and most widely known ciphers is a Caesar cipher, also known as a shift cipher. In a shift cipher the meanings of the letters are shifted by some set amount.

      // A common modern use is the ROT13 cipher, where the values of the letters are shifted by 13 places. Thus A ↔ N, B ↔ O and so on.

      // Write a function which takes a ROT13 encoded string as input and returns a decoded string.

      // All letters will be uppercase. Do not transform any non-alphabetic character (i.e. spaces, punctuation), but do pass them on.

      // function rot13(str) {
      //   let newArr = [];
      //   let newStr;
      //   const converter = (code) => {
      //     let frm;
      //     if (code >= 65) {
      //       if (code - 13 < 65) {
      //         frm = String.fromCharCode(code + 13);
      //       } else {
      //         frm = String.fromCharCode(code - 13);
      //       }
      //     } else {
      //       frm = String.fromCharCode(code);
      //     }
      //     return frm;
      //   };

      //   for (let i = 0; i < str.length; i++) {
      //     let rep = conveter(str.charCodeAt(i));
      //     newArr.push(rep);
      //   }
      //   newStr = newArr.join("");
      //   return newStr;
      // }

      //OR

      // function rot13(str) {
      //   return str.replace(/[A-Z]/g, (s) =>
      //     String.fromCharCode((s.charCodeAt(0) % 26) + 65)
      //   );
      // }

      // rot13("SERR PBQR PNZC");
      // rot13("GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT.");

      //3)Convert the given number into a roman numeral.
      // example link:-https://javascript.plainenglish.io/leetcode-12-integer-to-roman-javascript-21459e45a0ee

      // function convertToRoman(num) {
      //   const map = {
      //     M: 1000,
      //     CM: 900,
      //     D: 500,
      //     CD: 400,
      //     C: 100,
      //     XC: 90,
      //     L: 50,
      //     XL: 40,
      //     X: 10,
      //     IX: 9,
      //     V: 5,
      //     IV: 4,
      //     I: 1,
      //   };
      //   let result = "";
      //   for (let key in map) {
      //     //so here actually we're checking how many symbols do we need
      //     result += key.repeat(Math.floor(num / map[key]));
      //     num = num % map[key];
      //   }
      //   return result;
      // }

      //OR
      // const intToRoman = (num) => {
      //   const map = {
      //     M: 1000,
      //     CM: 900,
      //     D: 500,
      //     CD: 400,
      //     C: 100,
      //     XC: 90,
      //     L: 50,
      //     XL: 40,
      //     X: 10,
      //     IX: 9,
      //     V: 5,
      //     IV: 4,
      //     I: 1,
      //   };
      //   let result = "";

      //   for (key in map) {
      //     const repeatCounter = Math.floor(num / map[key]);

      //     if (repeatCounter !== 0) {
      //       result += key.repeat(repeatCounter);
      //     }

      //     num %= map[key];

      //     if (num === 0) return result;
      //   }

      //   return result;
      // };

      // convertToRoman(501);

      //5)Design a cash register drawer function checkCashRegister() that accepts purchase price as the first argument (price), payment as the second argument (cash), and cash-in-drawer (cid) as the third argument.

      // cid is a 2D array listing available currency.

      // The checkCashRegister() function should always return an object with a status key and a change key.

      // Return {status: "INSUFFICIENT_FUNDS", change: []} if cash-in-drawer is less than the change due, or if you cannot return the exact change.

      // Return {status: "CLOSED", change: [...]} with cash-in-drawer as the value for the key change if it is equal to the change due.

      // Otherwise, return {status: "OPEN", change: [...]}, with the change due in coins and bills, sorted in highest to lowest order, as the value of the change key.

      // Currency Unit	Amount:

      // Penny	$0.01 (PENNY)
      // Nickel	$0.05 (NICKEL)
      // Dime	$0.1 (DIME)
      // Quarter	$0.25 (QUARTER)
      // Dollar	$1 (ONE)
      // Five Dollars	$5 (FIVE)
      // Ten Dollars	$10 (TEN)
      // Twenty Dollars	$20 (TWENTY)
      // One-hundred Dollars	$100 (ONE HUNDRED)

      //Answer
      // function checkCashRegister(price, cash, cid) {
      //   const changeOrder = {
      //     "ONE HUNDRED": 100,
      //     TWENTY: 20,
      //     TEN: 10,
      //     FIVE: 5,
      //     ONE: 1,
      //     QUARTER: 0.25,
      //     DIME: 0.1,
      //     NICKEL: 0.05,
      //     PENNY: 0.01,
      //   };
      //   let totalChange = cash - price;
      //   let finalObj = { status: "", change: [] };
      //   const totalFunds = cid.reduce((acc, curr) => (acc += curr[1]), 0);
      //   const myFunc = (key, getVal) => {
      //     console.log(getVal);
      //     if (!totalChange <= 0) {
      //       finalObj.status = "OPEN";
      //       if (finalObj.change.length) {
      //         if (Boolean(finalObj.change.find((e) => e[0] === key))) {
      //           finalObj.change.find((e) => e[0] === key)[1] += getVal;
      //         } else {
      //           finalObj.change.push([key, getVal]);
      //         }
      //       } else {
      //         finalObj.change.push([key, getVal]);
      //       }
      //       totalChange = parseFloat(totalChange - getVal).toFixed(2);
      //     }

      //     console.log("remain Change", totalChange);
      //   };

      //   if (totalChange < totalFunds) {
      //     for (let key in changeOrder) {
      //       if (totalChange > changeOrder[key]) {
      //         const value = cid.find((e) => e[0] === key);
      //         for (let i = 0; i < value[1]; value[1] -= changeOrder[key]) {
      //           if (changeOrder[key] <= totalChange && value[1]) {
      //             myFunc(key, changeOrder[key]);
      //           }
      //         }
      //       }
      //     }
      //   } else if (totalFunds === totalChange) {
      //     finalObj = {
      //       status: "CLOSED",
      //       change: cid,
      //     };
      //   } else if (totalFunds < totalChange) {
      //     finalObj = {
      //       status: "INSUFFICIENT_FUNDS",
      //       change: [],
      //     };
      //   }
      //   if (finalObj.status === "OPEN" && totalChange > 0) {
      //     (finalObj.status = "INSUFFICIENT_FUNDS"), (finalObj.change = []);
      //   }
      //   console.log(finalObj);
      //   return finalObj;
      // }

      //Test cases

      // checkCashRegister(19.5, 20, [["PENNY", 1.01], ["NICKEL", 2.05], ["DIME", 3.1], ["QUARTER", 4.25], ["ONE", 90], ["FIVE", 55], ["TEN", 20], ["TWENTY", 60], ["ONE HUNDRED", 100]]);

      // checkCashRegister(3.26, 100, [
      //   ["PENNY", 1.01],
      //   ["NICKEL", 2.05],
      //   ["DIME", 3.1],
      //   ["QUARTER", 4.25],
      //   ["ONE", 90],
      //   ["FIVE", 55],
      //   ["TEN", 20],
      //   ["TWENTY", 60],
      //   ["ONE HUNDRED", 100],
      // ]);

      // checkCashRegister(19.5, 20, [["PENNY", 0.5], ["NICKEL", 0], ["DIME", 0], ["QUARTER", 0], ["ONE", 0], ["FIVE", 0], ["TEN", 0], ["TWENTY", 0], ["ONE HUNDRED", 0]])

      // checkCashRegister(19.5, 20, [["PENNY", 0.01], ["NICKEL", 0], ["DIME", 0], ["QUARTER", 0], ["ONE", 1], ["FIVE", 0], ["TEN", 0], ["TWENTY", 0], ["ONE HUNDRED", 0]])

      // const n = 7;
      // const ar = [10, 20, 20, 10, 10, 30, 50, 10, 20];

      // const find_ans = () => {
      //   let sockCount = {};
      //   let pairCount = 0;

      //   //Divide into number of pairs
      //   for (let ele of ar) {
      //     let sock = ele;

      //     if (sockCount[sock]) {
      //       sockCount[sock]++;
      //     } else {
      //       sockCount[sock] = 1;
      //     }
      //   }

      //   //Count unique socks
      //   for (let sock in sockCount) {
      //     const pairs = Math.floor(sockCount[sock] / 2);
      //     pairCount += pairs;
      //   }

      //   return pairCount;
      // };
      // console.log(find_ans());

      // console.log(x);
      // getNum();
      // let x = 7;

      // function getNum() {
      //   console.log("hello");
      // }

      // let arr = [
      //   [1, 2],
      //   [2, 3, 4, 5],
      //   [6, [7, 8, 9], 10],
      //   [11, 12],
      // ];

      // function customFlat(arr, depth = 1) {
      //   let result = [];
      //   arr.forEach((element) => {
      //     if (Array.isArray(element) && depth > 0) {
      //       result.push(...customFlat(element, depth - 1));
      //     } else result.push(element);
      //   });
      //   return result;
      // }

      // console.log(customFlat(arr, 2));

      //single promise
      // const a = new Promise((res, rej) => {
      //   setTimeout(() => res("success"));
      //   // rej("failed");
      // });

      // a.then((val) => console.log(val)).catch((err) => console.log(err));

      //Implement promise.all

      // const promise1 = Promise.resolve("hello");
      // const promise2 = Promise.resolve("world");
      // const promise3 = Promise.reject("bye");

      //if one of the promise will reject it will reject all the promises of promise.all
      // Promise.all([promise1, promise2, promise3]).then((val) =>
      //   console.log(val)
      // );

      //create polyfill function of promise.all

      // function myPromiseAll(promises) {
      //   let result = [];
      //   return new Promise((resolve, reject) => {
      //     promises.forEach((p, index) => {
      //       p.then((val) => {
      //         result.push(val);
      //         if (index === promises.length - 1) {
      //           resolve(result);
      //         }
      //       }).catch((err) => reject(err));
      //     });
      //   });
      // }

      // myPromiseAll([Promise.resolve("hello"), Promise.resolve("hi")]).then(
      //   (val) => console.log(val)
      // );

      //function is bundled with it's lexical function forms a closure or we can say function along with it's scope

      // clouser is combination of function and it's lexical scope bundle together
      // function x() {
      //   let a = 2;

      //   function y() {
      //     console.log(a);
      //   }
      //   return y;
      // }
      // const z = x();

      // .....

      // z();

      //deep level of closure
      // function z() {
      //   var a = 900;

      //   function y() {
      //     let b = 22;

      //     function x() {
      //       console.log(a, b);
      //     }
      //     x();
      //   }
      //   y();
      // }
      // z();

      // with recusion effect we can use setTimeout() function like setInterval()

      // function myFunction() {
      //   // Do something here
      //   console.log("called");
      //   setTimeout(myFunction, 1000); // Call myFunction again after 1 second (1000 milliseconds)
      // }

      // // Start the "interval" by calling the function for the first time
      // myFunction();

      // const myArr = [2, 3, 5, 4, 6];

      //polyfill for the map function
      // Array.map((ele,i,arr)=>{})

      // Array.prototype.myMap = function (cb) {
      //   let result = [];

      //   for (let i = 0; i < this.length; i++) {
      //     result.push(cb(this[i], i, this));
      //   }
      //   return result;
      // };

      //polyfill for the filter
      // Array.prototype.myFilter = function (cb) {
      //   let result = [];

      //   for (let i = 0; i < this.length; i++) {
      //     if (cb(this[i], i, this)) result.push(this[i]);
      //   }
      //   return result;
      // };

      // polyfill for the reduce

      //Main point theory of the reduce function is that if user is not give any initial value the reduce funtion will take the first element as a initial value

      // Array.prototype.myReduce = function (cb, initialVal) {
      //   // cb(initialVal,curr,i,arr)
      //   var acc = initialVal;
      //   for (let i = 0; i < this.length; i++) {
      //     acc = acc ? cb(acc, this[i], i, this) : this[i];
      //   }
      //   return acc;
      // };

      //------------------------javascript currying----------------------------

      //Currying is the function that return the function and that expects the next argument fot that , so those kind of function know as currying

      // uses : - to create higher order function , when we don't want add same variable as a parameter in function

      //  const sum = (a,b,c)=>{
      //   return a+b+c
      // }

      // const sum = (a) => {
      //   return (b) => {
      //     return (c) => {
      //       return `${a + b + c}`;
      //     };
      //   };
      // };
      // console.log(sum(2)(3)(5));

      //Practical example of currying

      // const evaluate = (oprationName) => {
      //   return function (a) {
      //     return function (b) {
      //       if (oprationName === "sum") return a + b;
      //       else if (oprationName === "sub") return a - b;
      //       else if (oprationName === "mul") return a * b;
      //       return a / b;
      //     };
      //   };
      // };

      // console.log(evaluate("mul")(4)(2));

      //Infinite currying

      // function sum(a) {
      //   return (b) => {
      //     if (b) return sum(a + b);
      //     return a;
      //   };
      // }

      // console.log(sum(2)(3)(5)());

      //DOM manipulation with currying

      // function updateTheHeading(id) {
      //   return (updatedText) => {
      //     document.querySelector(`#${id}`).innerText = updatedText;
      //   };
      // }

      // updateTheHeading("heading")("Hello this is manipulation");

      // function createBase(num) {
      //   return (a) => {
      //     console.log(num + a);
      //   };
      // }

      // var addSix = createBase(6);
      // addSix(10); // 16
      // addSix(21); //27

      // for (var i = 0; i < 3; i++) {
      //   setTimeout(() => {
      //     console.log(i);
      //   }, i * 1000);
      // }

      // for (var i = 0; i < 3; i++) {
      //   function newOne(i) {
      //     setTimeout(() => {
      //       console.log(i);
      //     }, i * 1000);
      //   }
      //   newOne(i);
      // }

      //event propagation bubbling/capturing

      //if you want stop bubbling effect use stoppropagation as below example

      // const div = document.querySelector("div");
      // const form = document.querySelector("form");
      // const button = document.querySelector("button");

      // button.addEventListener("click", (e) => {
      //   alert("button clicked");
      // });
      // div.addEventListener(
      //   "click",
      //   (e) => {
      //     alert("div clicked");
      //   },
      //   { capture: true }
      // );
      // form.addEventListener(
      //   "click",
      //   () => {
      //     alert("form clicked");
      //   },
      //   { capture: true }
      // );

      //event delegation
      //Instead of writing each click function for each product we are going to apply click to all products main tag and apply the functionality to there just like below example
      // const products = document.querySelector(".products");

      // products.addEventListener("click", (e) => {
      //   window.location.href = "/" + e.target.className;
      // });

      //recursion example

      //multiply answer

      // const multiplyVals = (arr, n) => {
      //   if (n <= 0) {
      //     return 1;
      //   } else {
      //     return multiplyVals(arr, n - 1) * arr[n - 1];
      //   }
      // };
      // let myarr = [1, 2, 3, 4];

      // console.log(multiplyVals(myarr, myarr.length));

      //Total sum

      // const sumTotal = (arr, n) => {
      //   if (n === 0) {
      //     return 0;
      //   }
      //   return sumTotal(arr, n - 1) + arr[n - 1];
      // };

      // console.log(sumTotal([1, 2, 3, 4, 5], [1, 2, 3, 4, 5].length));

      //factorial sum with recursion

      // const factorialFunc = (n) => {
      //   if (n === 0) return 1;
      //   return n * factorialFunc(n - 1);
      // };
      // console.log(factorialFunc(4));

      //create array for the range of the number

      // const rangeFunc = (start, end) => {
      //   //base case
      //   if (start > end) {
      //     return [];
      //   }
      //   const numbers = rangeFunc(start, end - 1);
      //   numbers.unshift(end);
      //   return numbers;
      // };

      // console.log(rangeFunc(0, 5));

    </script>
  </body>
</html>
